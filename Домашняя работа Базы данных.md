Домашняя работа по теме "Базы данных"

Детушев Дмитрий

Группа SQLDB-9

### Легенда

Заказчик передал вам [файл в формате Excel](https://github.com/netology-code/sdb-homeworks/blob/main/resources/hw-12-1.xlsx), в котором сформирован отчёт. 

На основе этого отчёта нужно выполнить следующие задания.

### Задание 1

create schema dom_bd14

set search_path to dom_bd14

Чтобы таблица удовлетворяла 1НФ, значения в каждом столбце должны быть  атомарными. То есть, 
значения в домене каждого атрибута отношения не являются ни списками, ни множествами простых 
или сложных значений.
Для этого в столбцах "Адрес филиала" и "Проект на который назначен" хранятся множества данных, 
можно данные по адресам и проектам вынести в отдельные таблицы:
```sql
CREATE TABLE "Проекты" (
"id_проекта" int4 NOT null PRIMARY key,
"Проект" varchar(30) NOT null)
```
```sql
CREATE TABLE "Регион" (
	"id_региона" int4 NOT null PRIMARY KEY,
	"Регион" varchar(50) NOT null)
```    
```sql
CREATE TABLE "Город" (
	"id_города" int4 NOT null PRIMARY KEY,
	"id_региона" int4 NOT null references "Регион" ("id_региона"),
	"Город" varchar(50) NOT null)
```
```sql	
CREATE TABLE "Улица" (
	"id_улицы" int4 NOT null PRIMARY KEY,
	"id_города" int4 NOT null references "Город" ("id_города"),
	"Улица" varchar(50) NOT null)
```	
```sql	
CREATE TABLE "Дом" (
	"id_дома" int4 NOT null PRIMARY KEY,
	"id_улицы" int4 NOT null references "Улица" ("id_улицы"),
	"Дом" varchar(50) NOT null)
```
Чтобы соответствовать 2НФ и удалить дубликаты, каждый неключевой атрибут должен зависеть от 
всего ключа, а не только от его части.
    1.В таблице создадим идентификатор, который сделаем первичным ключом.
	2.Столбец "Тип подразделения" и "Адрес филиала" зависит от столбца "Структурное подразделение", 
	вынесем столбецы в отдельную таблицу.

```sql
CREATE TABLE "Структурное подразделение" (
	"id_подразделение" int4 NOT null PRIMARY KEY,
	"структурное подразделение" varchar(100) NOT null,
	"тип подразделения" varchar(100) NOT null,
	"id_региона" int4 NOT null references "Регион"("id_региона"),
	"id_города" int4 NOT null references "Город" ("id_города"),
	"id_улицы" int4 NOT null references "Улица" ("id_улицы"),
	"id_дома" int4 NOT null references "Дом" ("id_дома")
	)
```	
    
Для соответствия 3НФ создадим таблицу соответствия столбца "Структурное подразделение" 
идентификатору "id_сотрудника"  и уберем лишние атрибуты из таблицы "Сотрудники".

```sql
CREATE TABLE "Сотрудники" (
	"id_сотрудника" int4 NOT null PRIMARY KEY,
	"Фамилия" varchar(50) NOT NULL,
	"Имя" varchar(50) not NULL,
	"Отчество" varchar(50) not null,
	"id_должности" int4 NOT null,
	"id_проекта" int4 NOT null,
	"id_подразделение" int4 NOT null,
	"Дата найма" date not null)
```
```sql	
CREATE TABLE "Оклад" (
    "id_сотрудника" int4 NOT null references "Сотрудник"("id_сотрудника"),
    "Оклад" int4 not null)	
```
```sql	
CREATE TABLE "Люди" (
	"id_чел" int4 NOT null PRIMARY KEY,
	"Фамилия" varchar(50) NOT NULL,
	"Имя" varchar(50) not NULL,
	"Отчество" varchar(50) not NULL)
```
```sql	
CREATE TABLE "Должность" (
	"id_должности" int4 NOT null PRIMARY KEY,
	"Должность" varchar(250) NOT null)	
```	
Нормальная форма Бойса-Кодда (НФБК)

```sql
CREATE TABLE "Сотрудники" (
	"id_сотрудника" int4 NOT null PRIMARY KEY,
	"id_проекта" int4 NOT null PRIMARY KEY,
	"id_чел" int4 NOT null,
	"id_должности" int4 NOT null,
	"id_подразделение" int4 NOT null,
	"Дата найма" date not null)	
```	
Приведем эту таблицу к 4НФ 

Создадим таблицу с отношением многие ко многим
```sql
CREATE TABLE "Сотрудник-проект" (
	"id_сотрудника" int4 references "Сотрудник"("id_сотрудника"),
	"id_проекта" int4 references "Проекты"("id_проекта"),
	primary key ("id_сотрудника", "id_проекта")
	)
```
```sql
CREATE TABLE "Сотрудник" (
	"id_сотрудника" int4 NOT null PRIMARY KEY,
	"id_чел" int4 NOT null references "Люди" ("id_чел"),
	"id_должности" int4 NOT null references "Должность" ("id_должности"),
	"id_подразделение" int4 NOT null references "Структурное подразделение" ("id_подразделение"),
	"Дата найма" date not null)	
```



### Задание 2*

Перечислите, какие, на ваш взгляд, в этой денормализованной таблице встречаются функциональные зависимости и какие правила вывода нужно применить, чтобы нормализовать данные.

Под функциональной зависимостью подразумевается зависимость значения одного атрибута от другого.
Если даны два атрибута А и Б некоторого отношения, то говорят, что Б функционально зависит от А, если в любой момент времени каждому значению А соответствует ровно одно значение Б.
Если возьмем любую таблицу, то значения в кортеже функционально зависят от значений первичного ключа этой таблицы.

Избыточной зависимостью называют ситуацию, при которой зависимость заключает информацию, которая может быть получена из других зависимостей.

Правила вывода зависимостей применяются к списку функциональных зависимостей с целью избавиться от избыточных зависимостей.

Аксиомы Армстронга - это набор правил (правила вывода), которые при многократном применении генерируют замыкание функциональных зависимостей.

Рефлексивность - если B является подмножеством  А, то А функционально определяет B.

Данная зависимость является тривиальной, правая часть таких зависимостей содержится в левой. То есть А -> B.

Пополнение - если  А функционально определяет B, то AC функционально определяет BC. То есть если A -> B, то AC -> BC.

Транзитивность - если А функционально определяет B и B функционально определяет С, то А функционально определяет С.

То есть если A -> B и B -> C, то A -> C. Такая зависимость является избыточной и должна быть устранена. Любой неключевой атрибут не должен быть зависим от атрибута, который не является первичным ключом отношения.

Дополнительные правила вывода

Самодетерминированность - когда A -> A, что прямо следует из аксиомы Рефлексивности.

Декомпозиция - если A -> BC, то A -> B и A -> C, согласно рефлексивности следует, что BC -> B, согласно транзитивности следует, что A -> B, таким же образом из BC -> С и транзитивности следует зависимость A -> C

Объединение  - если A -> B и A -> C, то A -> BC, согласно аксиомы Пополнения следует, что A -> AB и AB -> BC, а согласно транзитивности следует, что A -> BC

Композиция - когда A -> B и C -> D, то AC -> BD, согласно пополнения получим зависимость AС -> BС и BC -> BD, а применив транзитивность получим, что AC -> BD

Накопление  - если A -> BC и B -> D, то A -> BCD, применяя пополнение получим, что
BС -> BCD и применяя транзитивность получим, что A -> BCD.
